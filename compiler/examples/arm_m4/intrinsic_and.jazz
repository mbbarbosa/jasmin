export
fn and(reg u32 arg0, reg u32 arg1) -> reg u32 {
  reg u32 x;
  x = #AND(arg0, arg1);

  // Shifts.
  x = #AND(x, arg0, #LSL(0));
  x = #AND(x, arg0, #LSL(31));
  x = #AND(x, arg0, #LSR(1));
  x = #AND(x, arg0, #LSR(32));
  x = #AND(x, arg0, #ASR(1));
  x = #AND(x, arg0, #ASR(32));
  x = #AND(x, arg0, #ROR(1));
  x = #AND(x, arg0, #ROR(31));
  x = #AND(x, arg0, #RRX(1));

  // Set flags.
  reg bool n, z, v, c;
  n, z, c, v, x = #ANDS(x, arg0);
  n, z, c, v, x = #ANDS(x, arg0, #LSL(3));

  // Conditions.
  x = #ANDcc(x, arg0, z, x); // EQ
  x = #ANDcc(x, arg0, z, x); // NE
  x = #ANDcc(x, arg0, c, x); // CS
  x = #ANDcc(x, arg0, c, x); // CC
  x = #ANDcc(x, arg0, n, x); // MI
  x = #ANDcc(x, arg0, n, x); // PL
  x = #ANDcc(x, arg0, v, x); // VS
  x = #ANDcc(x, arg0, v, x); // VC

  // Should not be in an IT block.
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, v, x);

  // Should be in two IT blocks.
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);
  x = #ANDcc(x, arg0, z, x);

  n, z, c, v, x = #ANDScc(x, arg0, z, n, z, c, v, x);
  x = #ANDcc(x, arg0, #LSL(3), z, x);
  n, z, c, v, x = #ANDScc(x, arg0, #LSL(3), z, n, z, c, v, x);

  reg u32 res;
  res = x;
  return res;
}
